--q1) Update the Store table so that all stores have opening data on or after 1 jan 2014, populate random dates

use d
select * from dimstore;

select * from dimcustomer;

select  datediff(day,'2014-01-01',current_date )
--answer is 4197
select dateadd(day,uniform(0, 4197,random()), '2014-01-01')

update dimstore set storeopeningdate= dateadd(day, uniform(0, 4197, random()),'2014-01-01')


select * from dimstore;


--q2 Update the store table so that stores with  storied between 91 and 100  are opened in the last 12 months

SELECT * FROM DIMSTORE WHERE  STOREID BETWEEN 91 AND 100;

SELECT DATEADD(YEAR, -1, CURRENT_DATE)


--365
SELECT DATEADD(DAY,UNIFORM(0,365,RANDOM()),'2024-05-29')

UPDATE DIMSTORE SET STOREOPENINGDATE= DATEADD(DAY,UNIFORM(0,365,RANDOM()),'2024-05-29') WHERE  STOREID BETWEEN 91 AND 100;
COMMIT;

--QUERY 3 UPDATE THE CUSTOMER TABLE SO THAT ALL  CUSTOMERS ARE AT LEAST  12 YEAR OLD ,  ANY CUSTOMER  THART IS LESS THAN 12 YEAR OLD SUBTRACT 12 YEAR  FROM DOB

SELECT * FROM  DIMCUSTOMER WHERE DATEOFBIRTH >= DATEADD(YEAR,-12, CURRENT_DATE);

UPDATE DIMCUSTOMER  SET DATEOFBIRTH= DATEADD(YEAR,-12, CURRENT_DATE) WHERE DATEOFBIRTH >= DATEADD(YEAR,-12, CURRENT_DATE);

SELECT DATEADD(YEAR,-12, CURRENT_DATE);

COMMIT;


--QUERY4  wE MIFGHT HVAE  SOME ORDERS IN THE FACT TABLE  THAT MAY HAVE A DATEID WHICH HAVE  VALUE EVEN BEFORE  THE STORE WAS OPENED

-- FOR EXAMPLE, A STORE  WAS OPENED LAST YEAR  BUT WE HAVE AN ORDER  FROM 10 YEARS AGO  WHICH IS INCCORECT

-- UPDATE DATE ID  IN ORDER TABLE  FOR SUCH ROWS  WITH TO HAVE A RANDOM DATE iD AFTER  THE OPENING  DATE TO  THEIR RESPECTIVE  STORES


SELECT  ORDERID, F.DATEID, S.STOREID, S.STOREOPENINGDATE FROM FACTORDERS F
JOIN DIMDATE D ON F.DATEID=D.DATEID
JOIN DIMSTORE S ON F.STOREID=S.STOREID;
WHERE D.DATE< S.STOREOPENINGDATE;


UPDATE FACTORDERS F SET F.DATEID=R.DATEID FROM
(SELECT ORDERID, D.DATEID FROM
(
SELECT  ORDERID,  DATEADD(DAY,DATEDIFF(DAY, S.STOREOPENINGDATE,CURRENT_DATE)*UNIFORM(1,10,RANDOM())*0.1 ,S.STOREOPENINGDATE )  AS NEW_DATE
FROM FACTORDERS F
JOIN DIMDATE D ON F.DATEID=D.DATEID
JOIN DIMSTORE S ON F.STOREID=S.STOREID
WHERE D.DATE< S.STOREOPENINGDATE) O
JOIN DIMDATE D ON O.NEW_DATE=D.DATE) R
WHERE F.ORDERID=R.ORDERID;


-- query 5 LIST  CUSTOMERS WHO HAVENT PLACED AN ORDER IN THE 30 DAYS

SELECT * FROM DIMCUSTOMER WHERE CUSTOMERID NOT IN(
SELECT DISTINCT  C.CUSTOMERID FROM DIMCUSTOMER C
JOIN FACTORDERS F ON C.CUSTOMERID=F.CUSTOMERID
JOIN  DIMDATE D ON F.DATEID=D.DATEID
WHERE D.DATE >= DATEADD(MONTH,-1,CURRENT_DATE));

--lIST THE STORE THAT WAS OPENED MORE RECENTLY ALONG WITH ITS SALES SINCE THEN

WITH STORE_RANK AS(

SELECT  STOREID, STOREOPENINGDATE, ROW_NUMBER() OVER (ORDER BY STOREOPENINGDATE DESC)
AS FINAL_RANK
FROM DIMSTORE),
MOST_RECENT_STORE AS
(
 SELECT STOREID FROM STORE_RANK WHERE FINAL_RANK=1
 ),
STORE_AMOUNT AS
(
SELECT O.STOREID, SUM(TOTALAMOUNT)  AS TOTALAMOUNT FROM FACTORDERS O JOIN MOST_RECENT_STORE S ON O.STOREID=S.STOREID
GROUP BY O.STOREID
)
SELECT S.* ,a.totalamount from dimstore s join store_amount a on s.storeid=a.storeid;

-- query 7--Find customers  who have ordered  products from  more than  3 categories in the last  8 months





WITH BASE_DATA AS (
    SELECT 
        FO.CUSTOMERID, 
        P.CATEGORY 
    FROM FACTORDERS FO 
    JOIN DIMDATE D ON FO.DATEID = D.DATEID
    JOIN DIMPRODUCT P ON FO.PRODUCTID = P.PRODUCTID
    WHERE D.DATE >= DATEADD(MONTH, -8, CURRENT_DATE)
    GROUP BY FO.CUSTOMERID, P.CATEGORY
)
SELECT 
    CUSTOMERID
FROM 
    BASE_DATA 
GROUP BY 
    CUSTOMERID
HAVING 
    COUNT(DISTINCT CATEGORY) > 3;

-- sql QUERY 8 gET MONTH-WISE  TOTAL SALES  FOR THE CURRENT YEAR

SELECT  MONTH, SUM(TOTALAMOUNT) AS MONTHLY_AMOUNT FROM FACTORDERS FO
JOIN DIMDATE D 
ON FO.DATEID=D.DATEID
WHERE D.YEAR= EXTRACT(YEAR FROM CURRENT_DATE)
GROUP BY MONTH
ORDER BY MONTH


--- QUERY 9  FIND THE MAXIMUM  OR  THE HIGHEST DISCOUNT GIVEN ON ANY ORDER IN THE LAST 2 YEARS

WITH BASE_DATA AS
(

SELECT  DISCOUNTAMOUNT, ROW_NUMBER() OVER(ORDER BY DISCOUNTAMOUNT DESC) AS DISCOUNTAMOUNT_RANK FROM FACTORDERS FO
JOIN DIMDATE D 
ON FO.DATEID=D.DATEID
WHERE D.DATE= DATEADD(YEAR,-3,CURRENT_DATE)
)

SELECT * FROM BASE_DATA WHERE DISCOUNTAMOUNT_RANK=1


--QUERY 10  CALCULATE TOTAL SALES BY MULTIPLYING THE  UNIT PRICE FROM PRODUCT COLUMN WITH QUANTITY ORDERED FROM FACT ORDERS

SELECT SUM(QUANTITYORDERED*UNITPRICE) FROM FACTORDERS FO JOIN DIMPRODUCT P
ON FO.PRODUCTID=P.PRODUCTID;

-- QUERY 11  SHOW THE CUSTOMER ID  OF THE CUSTOMER WHO HAS TAKEN THE MAXIMUM DISCOUNT IN THEIR LIFETIME.


-- RANK OR ROW_NUMBER IS MUCH PREFFERED 

-- MAX DOSCUOUNT BY CIUTOMER ID IN THEIR LIFE TIME
SELECT CUSTOMERID, SUM(DISCOUNTAMOUNT) AS  TOTAL_DISCOUNT_AMOUNT FROM FACTORDERS 
GROUP BY CUSTOMERID
ORDER BY SUM(DISCOUNTAMOUNT) DESC LIMIT 1;


-- QUERY 12  LIST THE CUSTOMES WHO HAS PLACED MAXIMUM ONUMBER OF ORDERS TUILL DATE


SELECT  CUSTOMERID, COUNT(ORDERID) FROM FACTORDERS 
GROUP BY CUSTOMERID 
ORDER BY COUNT(ORDERID) DESC  LIMIT 1;

-- OR

WITH BASE_DATA AS (
    SELECT 
        CUSTOMERID, 
        COUNT(ORDERID) AS ORDER_COUNT 
    FROM FACTORDERS FO
    GROUP BY CUSTOMERID
),
ORDER_RANK_DATA AS (
    SELECT  
        B.*, 
        ROW_NUMBER() OVER (ORDER BY ORDER_COUNT DESC) AS ORDER_RANK 
    FROM BASE_DATA B
)

SELECT 
    CUSTOMERID, 
    ORDER_COUNT 
FROM 
    ORDER_RANK_DATA 
WHERE 
    ORDER_RANK = 1;

---QUERY 13  SHOW THE TOP 3 BRANDS  ON THERE SALES IN THE LAST 1 YEAR

WITH BRAND_SALES AS
(
 SELECT P.BRAND, SUM(TOTALAMOUNT) AS TOTAL_SALES FROM FACTORDERS FO  JOIN DIMDATE D ON FO.DATEID=D.DATEID 
 JOIN DIMPRODUCT P ON FO.PRODUCTID=P.PRODUCTID 
 WHERE D.DATE >= DATEADD(YEAR,-1, CURRENT_DATE)
 GROUP BY BRAND
),
BRAND_SALES_RANK AS
(
 SELECT BS.* , ROW_NUMBER() OVER(ORDER BY  TOTAL_SALES DESC) AS   
 SALES_RANK  FROM BRAND_SALES BS
)

SELECT * FROM BRAND_SALES_RANK WHERE SALES_RANK<4


--- QUERY 14 IF THE DISCOUNT AMOUNT AND THE SHIPPING COST  WAS MADE STATIC AT 5 AND 8 % PERCENT  RESPECTIVELY,  WILL THE SUM OF NEW TOTAL AMOUNT BE GREATER THAN THE TOTAL AMOUNT WE HAVE


SELECT  SUM(ORDERAMOUNT- ORDERAMOUNT*0.05 - ORDERAMOUNT* 0.08)  AS NEW_AMOUNT,  SUM(TOTALAMOUNT) AS ORGINAL_AMOUNT FROM FACTORDERS F LIMIT 10;


SELECT CASE WHEN SUM(ORDERAMOUNT- ORDERAMOUNT*0.05 - ORDERAMOUNT* 0.08) > SUM(TOTALAMOUNT) THEN 'YES IT IS GREATER THAN ORIGINAL AMOUNT' ELSE 'NO, IT IS NOT GREATER THEN ORIGINAL AMOUNT'  END FROM FACTORDERS F LIMIT 20;

-- QUERY 15  SHARE THE NUMBER OF CUSTOMER AND THEIR CURRENT LOYALTY PROGRAM STATUS

SELECT LP.PROGRAMTIER, COUNT(CUSTOMERID) FROM DIMCUSTOMER D JOIN
DIMLOYALTYPROGRAM LP ON D.LOYALTYPROGRAMID=LP.LOYALTYPROGRAMID
GROUP BY LP.PROGRAMTIER

--qUERY 16 SHOW THE REGION CATEGORY WISE TOTAL AMOUNT FOR THE LAST 6 MONTHS


SELECT REGION, CATEGORY  FROM FACTORDERS FO
JOIN DIMDATE D ON FO.DATEID=D.DATEID
JOIN DIMPRODUCT P ON FO.PRODUCTID=P.PRODUCTID
JOIN DIMSTORE S ON FO.STOREID=S.STOREID
WHERE D.DATE >=DATEADD(MONTH,-6,CURRENT_DATE)
GROUP BY REGION, CATEGORY 


-- QUERY 17 SHOW THE TOP 5 PRODUCTS BASED ON QUANTITY ORDERED  IN THE LAST 5 YEARS

WITH QUANTITY_DATA AS
(
SELECT  FO.PRODUCTID, SUM(QUANTITYORDERED)  AS TOTAL_QUATITY_PURCHASED FROM FACTORDERS FO
JOIN DIMDATE D ON FO.DATEID=D.DATEID
WHERE D.DATE >= DATEADD(YEAR,-5,CURRENT_DATE)
GROUP BY FO.PRODUCTID
),
QUANTITY_RANK_DATA AS(
SELECT Q.*, ROW_NUMBER() OVER(ORDER BY TOTAL_QUATITY_PURCHASED DESC) AS QUANITY_WISERANK FROM QUANTITY_DATA Q
)
SELECT * FROM QUANTITY_RANK_DATA QRD
WHERE QUANITY_WISERANK<6


--- QUERY 18  LIST THE TOTAL  AMOUNT  FOR EACH Loyally program tier since 2023

select lp.programname, sum(totalamount) as total_amount_of_sales  from factorders fo
join dimdate d on fo.dateid = d.dateid
join dimcustomer c on fo.customerid=c.customerid
join dimloyaltyprogram lp on c.loyaltyprogramid=lp.loyaltyprogramid
where d.year>= 2023
group by lp.programname;

--Query 19  Calculate the revenue generated by each store manager in june 2024


select s.managername, sum(totalamount) as total_sales_generated
from factorders fo
join dimdate d on fo.dateid= d.dateid
join dimstore s on fo.storeid= s.storeid
where d.year =2024 and d.month=6
group by s.managername


-- Query 20 List the average order amount per store ,   along  with  the store name  and type for the year 2024


select s.storename, s.storetype,avg(orderamount) as average_amount_per_store from factorders fo
join dimdate d on fo.dateid=d.dateid
join dimstore s on fo.storeid=s.storeid
where d.year = 2024
group by  s.storename, s.storetype


-- Query 21  Readin from file -- query data from the customer csv file  that is presnt in the stage


---quering from staging file




SELECT 
    $1 AS FirstName, 
    $2 AS LastName, 
    $8 AS City
FROM 
    @TEST_DB.TEST_DB_SCHEMA.TESTSTAGE/DimCustomerData/DimCustomerData.csv 
    (FILE_FORMAT => CSV_SOURCE_FILE_FORMAT);

-- Query 22  Aggregate data share the count of  records in the Dim CustomerFile  from the stage
select * from dimcustomer;



SELECT 
    $1 AS CUSTOMERID, 
    COUNT(*) AS TOTAL_CUSTOMER_COUNT
FROM 
    @TEST_DB.TEST_DB_SCHEMA.TESTSTAGE/DimCustomerData/DimCustomerData.csv 
    (FILE_FORMAT => CSV_SOURCE_FILE_FORMAT)
GROUP BY 
    $1;



-- QUERY 23 
--FILTER DATA, SHARE THE RECORDS FROM DIM CUSTOMER FILE WHERE CUSTOMER dob  AFTER 1ST JAN  2000

SELECT 
    $1 AS FirstName, 
    $2 AS LastName, 
    $3 AS Gender,
    $5 AS DateOfBirth,
    $6 AS Email
    
FROM 

@TEST_DB.TEST_DB_SCHEMA.TESTSTAGE/DimCustomerData/DimCustomerData.csv 
    (FILE_FORMAT => CSV_SOURCE_FILE_FORMAT)
WHERE $4 > '2000-01-01'



-- Query 24 
--join dim customer and DimLoyalty staging table  and hhow the customer 1st name along with  the program tier they are part of

select * from dimcustomer;
select * from dimloyaltyprogram;

with customer_data as 
(
SELECT $1 AS FirstName, $12 as LoyaltyProgramID
FROM
@TEST_DB.TEST_DB_SCHEMA.TESTSTAGE/DimCustomerData/DimCustomerData.csv 
    (FILE_FORMAT => CSV_SOURCE_FILE_FORMAT)
),
LOYALTY_DATA AS
(
SELECT $1 AS LoyaltyProgramID,$3 as ProgramTier
FROM
@TEST_DB.TEST_DB_SCHEMA.TESTSTAGE/DimLoyaltyInfo/DimLoyaltyInfo.csv 
    (FILE_FORMAT => CSV_SOURCE_FILE_FORMAT)
)
SELECT FirstName, ProgramTier from customer_data c join loyalty_data l on c.LoyaltyProgramID= l.LoyaltyProgramID


-- Query 25
-- Join the Dim customer and DimLoyalty . Show the ProgramTier and the number of customer part of it. Give the column name as in aliad 'totalCount'



WITH CUSTOMER_DATA AS (
    SELECT 
        $1 AS FirstName, 
        $12 AS LoyaltyProgramID
    FROM 
        @TEST_DB.TEST_DB_SCHEMA.TESTSTAGE/DimCustomerData/DimCustomerData.csv 
        (FILE_FORMAT => CSV_SOURCE_FILE_FORMAT)
),
LOYALTY_DATA AS (
    SELECT 
        $1 AS LoyaltyProgramID,
        $3 AS ProgramTier
    FROM 
        @TEST_DB.TEST_DB_SCHEMA.TESTSTAGE/DimLoyaltyInfo/DimLoyaltyInfo.csv 
        (FILE_FORMAT => CSV_SOURCE_FILE_FORMAT)
)
SELECT 
    ProgramTier, 
    COUNT(1) AS TotalCount 
FROM 
    CUSTOMER_DATA C 
    JOIN LOYALTY_DATA L ON C.LoyaltyProgramID = L.LoyaltyProgramID
GROUP BY 
    ProgramTier;



